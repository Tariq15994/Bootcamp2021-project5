"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const aws_auth_1 = require("./aws-auth");
const common_1 = require("./hotswap/common");
const evaluate_cloudformation_template_1 = require("./hotswap/evaluate-cloudformation-template");
const lambda_functions_1 = require("./hotswap/lambda-functions");
/**
 * Perform a hotswap deployment,
 * short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting);
    // The current resources of the Stack.
    // We need them to figure out the physical name of a resource in case it wasn't specified by the user.
    // We fetch it lazily, to save a service call, in case all hotswapped resources have their physical names set.
    const listStackResources = new LazyListStackResources(sdk, stackArtifact.stackName);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackArtifact,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        // ToDo make this better:
        partition: 'aws',
        // ToDo make this better:
        urlSuffix: 'amazonaws.com',
        listStackResources,
    });
    const currentTemplate = await cloudFormationStack.template();
    const stackChanges = cfn_diff.diffTemplate(currentTemplate, stackArtifact.template);
    const hotswappableChanges = await findAllHotswappableChanges(stackChanges, evaluateCfnTemplate);
    if (!hotswappableChanges) {
        // this means there were changes to the template that cannot be short-circuited
        return undefined;
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs, stackArtifact };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
async function findAllHotswappableChanges(stackChanges, evaluateCfnTemplate) {
    const promises = new Array();
    stackChanges.resources.forEachDifference(async (logicalId, change) => {
        promises.push(lambda_functions_1.isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate));
    });
    return Promise.all(promises).then(hotswapDetectionResults => {
        const hotswappableResources = new Array();
        let foundNonHotswappableChange = false;
        for (const lambdaFunctionShortCircuitChange of hotswapDetectionResults) {
            if (lambdaFunctionShortCircuitChange === common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT) {
                foundNonHotswappableChange = true;
            }
            else if (lambdaFunctionShortCircuitChange === common_1.ChangeHotswapImpact.IRRELEVANT) {
                // empty 'if' just for flow-aware typing to kick in...
            }
            else {
                hotswappableResources.push(lambdaFunctionShortCircuitChange);
            }
        }
        return foundNonHotswappableChange ? undefined : hotswappableResources;
    });
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    return Promise.all(hotswappableChanges.map(hotswapOperation => {
        return hotswapOperation.apply(sdk);
    }));
}
class LazyListStackResources {
    constructor(sdk, stackName) {
        this.sdk = sdk;
        this.stackName = stackName;
    }
    async listStackResources() {
        if (this.stackResources === undefined) {
            this.stackResources = await this.getStackResources();
        }
        return this.stackResources;
    }
    async getStackResources() {
        var _a;
        const ret = new Array();
        let nextToken;
        do {
            const stackResourcesResponse = await this.sdk.cloudFormation().listStackResources({
                StackName: this.stackName,
                NextToken: nextToken,
            }).promise();
            ret.push(...((_a = stackResourcesResponse.StackResourceSummaries) !== null && _a !== void 0 ? _a : []));
            nextToken = stackResourcesResponse.NextToken;
        } while (nextToken);
        return ret;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBR3pELHlDQUFxRDtBQUVyRCw2Q0FBa0g7QUFDbEgsaUdBQTRGO0FBQzVGLGlFQUFnRjtBQUdoRjs7Ozs7O0dBTUc7QUFDSSxLQUFLLFVBQVUsb0JBQW9CLENBQ3hDLFdBQXdCLEVBQUUsV0FBc0MsRUFDaEUsbUJBQXdDLEVBQUUsYUFBZ0Q7SUFFMUYsMkZBQTJGO0lBQzNGLE1BQU0sV0FBVyxHQUFHLE1BQU0sV0FBVyxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNwRiw4R0FBOEc7SUFDOUcsa0dBQWtHO0lBQ2xHLE1BQU0sR0FBRyxHQUFHLE1BQU0sV0FBVyxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsZUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzNFLHNDQUFzQztJQUN0QyxzR0FBc0c7SUFDdEcsOEdBQThHO0lBQzlHLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BGLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxpRUFBOEIsQ0FBQztRQUM3RCxhQUFhO1FBQ2IsVUFBVSxFQUFFLFdBQVc7UUFDdkIsT0FBTyxFQUFFLFdBQVcsQ0FBQyxPQUFPO1FBQzVCLE1BQU0sRUFBRSxXQUFXLENBQUMsTUFBTTtRQUMxQix5QkFBeUI7UUFDekIsU0FBUyxFQUFFLEtBQUs7UUFDaEIseUJBQXlCO1FBQ3pCLFNBQVMsRUFBRSxlQUFlO1FBQzFCLGtCQUFrQjtLQUNuQixDQUFDLENBQUM7SUFFSCxNQUFNLGVBQWUsR0FBRyxNQUFNLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzdELE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENB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O2dCQUNoRixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7Z0JBQ3pCLFNBQVMsRUFBRSxTQUFTO2FBQ3JCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxPQUFDLHNCQUFzQixDQUFDLHNCQUFzQixtQ0FBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ25FLFNBQVMsR0FBRyxzQkFBc0IsQ0FBQyxTQUFTLENBQUM7U0FDOUMsUUFBUSxTQUFTLEVBQUU7UUFDcEIsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgSVNESywgTW9kZSwgU2RrUHJvdmlkZXIgfSBmcm9tICcuL2F3cy1hdXRoJztcbmltcG9ydCB7IERlcGxveVN0YWNrUmVzdWx0IH0gZnJvbSAnLi9kZXBsb3ktc3RhY2snO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiwgTGlzdFN0YWNrUmVzb3VyY2VzIH0gZnJvbSAnLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuL2hvdHN3YXAvZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9sYW1iZGEtZnVuY3Rpb25zJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uU3RhY2sgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBob3Rzd2FwIGRlcGxveW1lbnQsXG4gKiBzaG9ydC1jaXJjdWl0aW5nIENsb3VkRm9ybWF0aW9uIGlmIHBvc3NpYmxlLlxuICogSWYgaXQncyBub3QgcG9zc2libGUgdG8gc2hvcnQtY2lyY3VpdCB0aGUgZGVwbG95bWVudFxuICogKGJlY2F1c2UgdGhlIENESyBTdGFjayBjb250YWlucyBjaGFuZ2VzIHRoYXQgY2Fubm90IGJlIGRlcGxveWVkIHdpdGhvdXQgQ2xvdWRGb3JtYXRpb24pLFxuICogcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyeUhvdHN3YXBEZXBsb3ltZW50KFxuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIGFzc2V0UGFyYW1zOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9LFxuICBjbG91ZEZvcm1hdGlvblN0YWNrOiBDbG91ZEZvcm1hdGlvblN0YWNrLCBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0IHwgdW5kZWZpbmVkPiB7XG4gIC8vIHJlc29sdmUgdGhlIGVudmlyb25tZW50LCBzbyB3ZSBjYW4gc3Vic3RpdHV0ZSB0aGluZ3MgbGlrZSBBV1M6OlJlZ2lvbiBpbiBDRk4gZXhwcmVzc2lvbnNcbiAgY29uc3QgcmVzb2x2ZWRFbnYgPSBhd2FpdCBzZGtQcm92aWRlci5yZXNvbHZlRW52aXJvbm1lbnQoc3RhY2tBcnRpZmFjdC5lbnZpcm9ubWVudCk7XG4gIC8vIGNyZWF0ZSBhIG5ldyBTREsgdXNpbmcgdGhlIENMSSBjcmVkZW50aWFscywgYmVjYXVzZSB0aGUgZGVmYXVsdCBvbmUgd2lsbCBub3Qgd29yayBmb3IgbmV3LXN0eWxlIHN5bnRoZXNpcyAtXG4gIC8vIGl0IGFzc3VtZXMgdGhlIGJvb3RzdHJhcCBkZXBsb3kgUm9sZSwgd2hpY2ggZG9lc24ndCBoYXZlIHBlcm1pc3Npb25zIHRvIHVwZGF0ZSBMYW1iZGEgZnVuY3Rpb25zXG4gIGNvbnN0IHNkayA9IGF3YWl0IHNka1Byb3ZpZGVyLmZvckVudmlyb25tZW50KHJlc29sdmVkRW52LCBNb2RlLkZvcldyaXRpbmcpO1xuICAvLyBUaGUgY3VycmVudCByZXNvdXJjZXMgb2YgdGhlIFN0YWNrLlxuICAvLyBXZSBuZWVkIHRoZW0gdG8gZmlndXJlIG91dCB0aGUgcGh5c2ljYWwgbmFtZSBvZiBhIHJlc291cmNlIGluIGNhc2UgaXQgd2Fzbid0IHNwZWNpZmllZCBieSB0aGUgdXNlci5cbiAgLy8gV2UgZmV0Y2ggaXQgbGF6aWx5LCB0byBzYXZlIGEgc2VydmljZSBjYWxsLCBpbiBjYXNlIGFsbCBob3Rzd2FwcGVkIHJlc291cmNlcyBoYXZlIHRoZWlyIHBoeXNpY2FsIG5hbWVzIHNldC5cbiAgY29uc3QgbGlzdFN0YWNrUmVzb3VyY2VzID0gbmV3IExhenlMaXN0U3RhY2tSZXNvdXJjZXMoc2RrLCBzdGFja0FydGlmYWN0LnN0YWNrTmFtZSk7XG4gIGNvbnN0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUgPSBuZXcgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKHtcbiAgICBzdGFja0FydGlmYWN0LFxuICAgIHBhcmFtZXRlcnM6IGFzc2V0UGFyYW1zLFxuICAgIGFjY291bnQ6IHJlc29sdmVkRW52LmFjY291bnQsXG4gICAgcmVnaW9uOiByZXNvbHZlZEVudi5yZWdpb24sXG4gICAgLy8gVG9EbyBtYWtlIHRoaXMgYmV0dGVyOlxuICAgIHBhcnRpdGlvbjogJ2F3cycsXG4gICAgLy8gVG9EbyBtYWtlIHRoaXMgYmV0dGVyOlxuICAgIHVybFN1ZmZpeDogJ2FtYXpvbmF3cy5jb20nLFxuICAgIGxpc3RTdGFja1Jlc291cmNlcyxcbiAgfSk7XG5cbiAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgY2xvdWRGb3JtYXRpb25TdGFjay50ZW1wbGF0ZSgpO1xuICBjb25zdCBzdGFja0NoYW5nZXMgPSBjZm5fZGlmZi5kaWZmVGVtcGxhdGUoY3VycmVudFRlbXBsYXRlLCBzdGFja0FydGlmYWN0LnRlbXBsYXRlKTtcbiAgY29uc3QgaG90c3dhcHBhYmxlQ2hhbmdlcyA9IGF3YWl0IGZpbmRBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHN0YWNrQ2hhbmdlcywgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gIGlmICghaG90c3dhcHBhYmxlQ2hhbmdlcykge1xuICAgIC8vIHRoaXMgbWVhbnMgdGhlcmUgd2VyZSBjaGFuZ2VzIHRvIHRoZSB0ZW1wbGF0ZSB0aGF0IGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWRcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gYXBwbHkgdGhlIHNob3J0LWNpcmN1aXRhYmxlIGNoYW5nZXNcbiAgYXdhaXQgYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKHNkaywgaG90c3dhcHBhYmxlQ2hhbmdlcyk7XG5cbiAgcmV0dXJuIHsgbm9PcDogaG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDAsIHN0YWNrQXJuOiBjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrSWQsIG91dHB1dHM6IGNsb3VkRm9ybWF0aW9uU3RhY2sub3V0cHV0cywgc3RhY2tBcnRpZmFjdCB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBmaW5kQWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgc3RhY2tDaGFuZ2VzOiBjZm5fZGlmZi5UZW1wbGF0ZURpZmYsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8SG90c3dhcE9wZXJhdGlvbltdIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IHByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4+KCk7XG4gIHN0YWNrQ2hhbmdlcy5yZXNvdXJjZXMuZm9yRWFjaERpZmZlcmVuY2UoYXN5bmMgKGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSkgPT4ge1xuICAgIHByb21pc2VzLnB1c2goaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShsb2dpY2FsSWQsIGNoYW5nZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSkpO1xuICB9KTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzID0+IHtcbiAgICBjb25zdCBob3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBuZXcgQXJyYXk8SG90c3dhcE9wZXJhdGlvbj4oKTtcbiAgICBsZXQgZm91bmROb25Ib3Rzd2FwcGFibGVDaGFuZ2UgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGxhbWJkYUZ1bmN0aW9uU2hvcnRDaXJjdWl0Q2hhbmdlIG9mIGhvdHN3YXBEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgICBpZiAobGFtYmRhRnVuY3Rpb25TaG9ydENpcmN1aXRDaGFuZ2UgPT09IENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UKSB7XG4gICAgICAgIGZvdW5kTm9uSG90c3dhcHBhYmxlQ2hhbmdlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobGFtYmRhRnVuY3Rpb25TaG9ydENpcmN1aXRDaGFuZ2UgPT09IENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVCkge1xuICAgICAgICAvLyBlbXB0eSAnaWYnIGp1c3QgZm9yIGZsb3ctYXdhcmUgdHlwaW5nIHRvIGtpY2sgaW4uLi5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKGxhbWJkYUZ1bmN0aW9uU2hvcnRDaXJjdWl0Q2hhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kTm9uSG90c3dhcHBhYmxlQ2hhbmdlID8gdW5kZWZpbmVkIDogaG90c3dhcHBhYmxlUmVzb3VyY2VzO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlBbGxIb3Rzd2FwcGFibGVDaGFuZ2VzKFxuICBzZGs6IElTREssIGhvdHN3YXBwYWJsZUNoYW5nZXM6IEhvdHN3YXBPcGVyYXRpb25bXSxcbik6IFByb21pc2U8dm9pZFtdPiB7XG4gIHJldHVybiBQcm9taXNlLmFsbChob3Rzd2FwcGFibGVDaGFuZ2VzLm1hcChob3Rzd2FwT3BlcmF0aW9uID0+IHtcbiAgICByZXR1cm4gaG90c3dhcE9wZXJhdGlvbi5hcHBseShzZGspO1xuICB9KSk7XG59XG5cbmNsYXNzIExhenlMaXN0U3RhY2tSZXNvdXJjZXMgaW1wbGVtZW50cyBMaXN0U3RhY2tSZXNvdXJjZXMge1xuICBwcml2YXRlIHN0YWNrUmVzb3VyY2VzOiBDbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc2RrOiBJU0RLLCBwcml2YXRlIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gIH1cblxuICBhc3luYyBsaXN0U3RhY2tSZXNvdXJjZXMoKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeVtdPiB7XG4gICAgaWYgKHRoaXMuc3RhY2tSZXNvdXJjZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdGFja1Jlc291cmNlcyA9IGF3YWl0IHRoaXMuZ2V0U3RhY2tSZXNvdXJjZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tSZXNvdXJjZXM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdldFN0YWNrUmVzb3VyY2VzKCk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uU3RhY2tSZXNvdXJjZVN1bW1hcnlbXT4ge1xuICAgIGNvbnN0IHJldCA9IG5ldyBBcnJheTxDbG91ZEZvcm1hdGlvbi5TdGFja1Jlc291cmNlU3VtbWFyeT4oKTtcbiAgICBsZXQgbmV4dFRva2VuOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZG8ge1xuICAgICAgY29uc3Qgc3RhY2tSZXNvdXJjZXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2RrLmNsb3VkRm9ybWF0aW9uKCkubGlzdFN0YWNrUmVzb3VyY2VzKHtcbiAgICAgICAgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgICAgTmV4dFRva2VuOiBuZXh0VG9rZW4sXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICByZXQucHVzaCguLi4oc3RhY2tSZXNvdXJjZXNSZXNwb25zZS5TdGFja1Jlc291cmNlU3VtbWFyaWVzID8/IFtdKSk7XG4gICAgICBuZXh0VG9rZW4gPSBzdGFja1Jlc291cmNlc1Jlc3BvbnNlLk5leHRUb2tlbjtcbiAgICB9IHdoaWxlIChuZXh0VG9rZW4pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbiJdfQ==