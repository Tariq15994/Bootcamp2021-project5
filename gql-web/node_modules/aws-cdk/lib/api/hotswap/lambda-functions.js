"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const common_1 = require("./common");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
/**
 * Returns `false` if the change cannot be short-circuited,
 * `true` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    else {
        // verify that the Asset changed - otherwise,
        // it's a Code property-only change,
        // but not to an asset change
        // (for example, going from Code.fromAsset() to Code.fromInline())
        if (!common_1.assetMetadataChanged(change)) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const functionName = await establishFunctionPhysicalName(logicalId, change, evaluateCfnTemplate);
        if (!functionName) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        return new LambdaFunctionHotswapOperation({
            physicalName: functionName,
            code: lambdaCodeChange,
        });
    }
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns `true` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `false` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    var _a;
    if (!change.newValue) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const newResourceType = change.newValue.Type;
    // Ignore Metadata changes
    if (newResourceType === 'AWS::CDK::Metadata') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // The only other resource change we should see is a Lambda function
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    if (((_a = change.oldValue) === null || _a === void 0 ? void 0 : _a.Type) == null) {
        // this means this is a brand-new Lambda function -
        // obviously, we can't short-circuit that!
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * On first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    let s3Bucket = '', s3Key = '';
    let foundCodeDifference = false;
    // Make sure only the code in the Lambda function changed
    const propertyUpdates = change.propertyUpdates;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        if (updatedProp.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        for (const newPropName in updatedProp.newValue) {
            switch (newPropName) {
                case 'S3Bucket':
                    foundCodeDifference = true;
                    s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                case 'S3Key':
                    foundCodeDifference = true;
                    s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                    break;
                default:
                    return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
            }
        }
    }
    return foundCodeDifference
        ? {
            s3Bucket,
            s3Key,
        }
        : common_1.ChangeHotswapImpact.IRRELEVANT;
}
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
    }
    async apply(sdk) {
        return sdk.lambda().updateFunctionCode({
            FunctionName: this.lambdaFunctionResource.physicalName,
            S3Bucket: this.lambdaFunctionResource.code.s3Bucket,
            S3Key: this.lambdaFunctionResource.code.s3Key,
        }).promise();
    }
}
async function establishFunctionPhysicalName(logicalId, change, evaluateCfnTemplate) {
    var _a, _b;
    const functionNameInCfnTemplate = (_b = (_a = change.newValue) === null || _a === void 0 ? void 0 : _a.Properties) === null || _b === void 0 ? void 0 : _b.FunctionName;
    if (functionNameInCfnTemplate != null) {
        try {
            return await evaluateCfnTemplate.evaluateCfnExpression(functionNameInCfnTemplate);
        }
        catch (e) {
            // If we can't evaluate the function's name CloudFormation expression,
            // just look it up in the currently deployed Stack
            if (!(e instanceof evaluate_cloudformation_template_1.CfnEvaluationException)) {
                throw e;
            }
        }
    }
    return evaluateCfnTemplate.findPhysicalNameFor(logicalId);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEscUNBQTRHO0FBQzVHLHlGQUE0RztBQUU1Rzs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxrQ0FBa0MsQ0FDdEQsU0FBaUIsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRDtJQUUzRyxNQUFNLGdCQUFnQixHQUFHLE1BQU0sOEJBQThCLENBQUMsTUFBTSxFQUFFLG1CQUFtQixDQUFDLENBQUM7SUFDM0YsSUFBSSxPQUFPLGdCQUFnQixLQUFLLFFBQVEsRUFBRTtRQUN4QyxPQUFPLGdCQUFnQixDQUFDO0tBQ3pCO1NBQU07UUFDTCw2Q0FBNkM7UUFDN0Msb0NBQW9DO1FBQ3BDLDZCQUE2QjtRQUM3QixrRUFBa0U7UUFDbEUsSUFBSSxDQUFDLDZCQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pDLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7UUFFRCxNQUFNLFlBQVksR0FBRyxNQUFNLDZCQUE2QixDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztRQUNqRyxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ2pCLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7UUFFRCxPQUFPLElBQUksOEJBQThCLENBQUM7WUFDeEMsWUFBWSxFQUFFLFlBQVk7WUFDMUIsSUFBSSxFQUFFLGdCQUFnQjtTQUN2QixDQUFDLENBQUM7S0FDSjtBQUNILENBQUM7QUF6QkQsZ0ZBeUJDO0FBRUQ7Ozs7Ozs7O0dBUUc7QUFDSCxLQUFLLFVBQVUsOEJBQThCLENBQzNDLE1BQW1DLEVBQUUsbUJBQW1EOztJQUV4RixJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtRQUNwQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBQ0QsTUFBTSxlQUFl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LENBQUMsQ0FBQyxDQUFDLFlBQVkseURBQXNCLENBQUMsRUFBRTtnQkFDMUMsTUFBTSxDQUFDLENBQUM7YUFDVDtTQUNGO0tBQ0Y7SUFDRCxPQUFPLG1CQUFtQixDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzVELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBhc3NldE1ldGFkYXRhQ2hhbmdlZCwgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IENmbkV2YWx1YXRpb25FeGNlcHRpb24sIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuXG4vKipcbiAqIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgY2hhbmdlIGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBgdHJ1ZWAgaWYgdGhlIGNoYW5nZSBpcyBpcnJlbGV2YW50IGZyb20gYSBzaG9ydC1jaXJjdWl0IHBlcnNwZWN0aXZlXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UgaWYgdGhlIGNoYW5nZSBjYW4gYmUgc2hvcnQtY2lyY3VpdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgY29uc3QgbGFtYmRhQ29kZUNoYW5nZSA9IGF3YWl0IGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShjaGFuZ2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICBpZiAodHlwZW9mIGxhbWJkYUNvZGVDaGFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxhbWJkYUNvZGVDaGFuZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhlIEFzc2V0IGNoYW5nZWQgLSBvdGhlcndpc2UsXG4gICAgLy8gaXQncyBhIENvZGUgcHJvcGVydHktb25seSBjaGFuZ2UsXG4gICAgLy8gYnV0IG5vdCB0byBhbiBhc3NldCBjaGFuZ2VcbiAgICAvLyAoZm9yIGV4YW1wbGUsIGdvaW5nIGZyb20gQ29kZS5mcm9tQXNzZXQoKSB0byBDb2RlLmZyb21JbmxpbmUoKSlcbiAgICBpZiAoIWFzc2V0TWV0YWRhdGFDaGFuZ2VkKGNoYW5nZSkpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG5cbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhd2FpdCBlc3RhYmxpc2hGdW5jdGlvblBoeXNpY2FsTmFtZShsb2dpY2FsSWQsIGNoYW5nZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZSk7XG4gICAgaWYgKCFmdW5jdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbih7XG4gICAgICBwaHlzaWNhbE5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgIGNvZGU6IGxhbWJkYUNvZGVDaGFuZ2UsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBmb3IgYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBidXQgZG9lc24ndCBwcmV2ZW50IHNob3J0LWNpcmN1aXRpbmdcbiAqIChsaWtlIGEgY2hhbmdlIHRvIENES01ldGFkYXRhIHJlc291cmNlKSxcbiAqIGBmYWxzZWAgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBub3Qgb25seSB0byBpdHMgQ29kZSBwcm9wZXJ0eSxcbiAqIG9yIGEgTGFtYmRhRnVuY3Rpb25Db2RlIGlmIHRoZSBjaGFuZ2UgaXMgdG8gYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBhbmQgb25seSBhZmZlY3RzIGl0cyBDb2RlIHByb3BlcnR5LlxuICovXG5hc3luYyBmdW5jdGlvbiBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoXG4gIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPExhbWJkYUZ1bmN0aW9uQ29kZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Q+IHtcbiAgaWYgKCFjaGFuZ2UubmV3VmFsdWUpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cbiAgY29uc3QgbmV3UmVzb3VyY2VUeXBlID0gY2hhbmdlLm5ld1ZhbHVlLlR5cGU7XG4gIC8vIElnbm9yZSBNZXRhZGF0YSBjaGFuZ2VzXG4gIGlmIChuZXdSZXNvdXJjZVR5cGUgPT09ICdBV1M6OkNESzo6TWV0YWRhdGEnKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbiAgfVxuICAvLyBUaGUgb25seSBvdGhlciByZXNvdXJjZSBjaGFuZ2Ugd2Ugc2hvdWxkIHNlZSBpcyBhIExhbWJkYSBmdW5jdGlvblxuICBpZiAobmV3UmVzb3VyY2VUeXBlICE9PSAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuICBpZiAoY2hhbmdlLm9sZFZhbHVlPy5UeXBlID09IG51bGwpIHtcbiAgICAvLyB0aGlzIG1lYW5zIHRoaXMgaXMgYSBicmFuZC1uZXcgTGFtYmRhIGZ1bmN0aW9uIC1cbiAgICAvLyBvYnZpb3VzbHksIHdlIGNhbid0IHNob3J0LWNpcmN1aXQgdGhhdCFcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cblxuICAvKlxuICAgKiBPbiBmaXJzdCBnbGFuY2UsIHdlIHdvdWxkIHdhbnQgdG8gaW5pdGlhbGl6ZSB0aGVzZSB1c2luZyB0aGUgXCJwcmV2aW91c1wiIHZhbHVlcyAoY2hhbmdlLm9sZFZhbHVlKSxcbiAgICogaW4gY2FzZSBvbmx5IG9uZSBvZiB0aGVtIGNoYW5nZWQsIGxpa2UgdGhlIGtleSwgYW5kIHRoZSBCdWNrZXQgc3RheWVkIHRoZSBzYW1lLlxuICAgKiBIb3dldmVyLCB0aGF0IGFjdHVhbGx5IGZhaWxzIGZvciBvbGQtc3R5bGUgc3ludGhlc2lzLCB3aGljaCB1c2VzIENGTiBQYXJhbWV0ZXJzIVxuICAgKiBCZWNhdXNlIHRoZSBuYW1lcyBvZiB0aGUgUGFyYW1ldGVycyBkZXBlbmQgb24gdGhlIGhhc2ggb2YgdGhlIEFzc2V0LFxuICAgKiB0aGUgUGFyYW1ldGVycyB1c2VkIGZvciB0aGUgXCJvbGRcIiB2YWx1ZXMgbm8gbG9uZ2VyIGV4aXN0IGluIGBhc3NldFBhcmFtc2AgYXQgdGhpcyBwb2ludCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZXMgYXZhaWxhYmxlIHRvIGV2YWx1YXRlIHRoZSBDRk4gZXhwcmVzc2lvbiB3aXRoLlxuICAgKiBGb3J0dW5hdGVseSwgdGhlIGRpZmYgd2lsbCBhbHdheXMgaW5jbHVkZSBib3RoIHRoZSBzM0J1Y2tldCBhbmQgczNLZXkgcGFydHMgb2YgdGhlIExhbWJkYSdzIENvZGUgcHJvcGVydHksXG4gICAqIGV2ZW4gaWYgb25seSBvbmUgb2YgdGhlbSB3YXMgYWN0dWFsbHkgY2hhbmdlZCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgbmVlZCB0aGUgXCJvbGRcIiB2YWx1ZXMgYXQgYWxsLCBhbmQgd2UgY2FuIHNhZmVseSBpbml0aWFsaXplIHRoZXNlIHdpdGgganVzdCBgJydgLlxuICAgKi9cbiAgbGV0IHMzQnVja2V0ID0gJycsIHMzS2V5ID0gJyc7XG4gIGxldCBmb3VuZENvZGVEaWZmZXJlbmNlID0gZmFsc2U7XG4gIC8vIE1ha2Ugc3VyZSBvbmx5IHRoZSBjb2RlIGluIHRoZSBMYW1iZGEgZnVuY3Rpb24gY2hhbmdlZFxuICBjb25zdCBwcm9wZXJ0eVVwZGF0ZXMgPSBjaGFuZ2UucHJvcGVydHlVcGRhdGVzO1xuICBmb3IgKGNvbnN0IHVwZGF0ZWRQcm9wTmFtZSBpbiBwcm9wZXJ0eVVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGVkUHJvcCA9IHByb3BlcnR5VXBkYXRlc1t1cGRhdGVkUHJvcE5hbWVdO1xuICAgIGlmICh1cGRhdGVkUHJvcC5uZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmV3UHJvcE5hbWUgaW4gdXBkYXRlZFByb3AubmV3VmFsdWUpIHtcbiAgICAgIHN3aXRjaCAobmV3UHJvcE5hbWUpIHtcbiAgICAgICAgY2FzZSAnUzNCdWNrZXQnOlxuICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgIHMzQnVja2V0ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUzNLZXknOlxuICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgIHMzS2V5ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvdW5kQ29kZURpZmZlcmVuY2VcbiAgICA/IHtcbiAgICAgIHMzQnVja2V0LFxuICAgICAgczNLZXksXG4gICAgfVxuICAgIDogQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25Db2RlIHtcbiAgcmVhZG9ubHkgczNCdWNrZXQ6IHN0cmluZztcbiAgcmVhZG9ubHkgczNLZXk6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2Uge1xuICByZWFkb25seSBwaHlzaWNhbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgY29kZTogTGFtYmRhRnVuY3Rpb25Db2RlO1xufVxuXG5jbGFzcyBMYW1iZGFGdW5jdGlvbkhvdHN3YXBPcGVyYXRpb24gaW1wbGVtZW50cyBIb3Rzd2FwT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBsYW1iZGFGdW5jdGlvblJlc291cmNlOiBMYW1iZGFGdW5jdGlvblJlc291cmNlKSB7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYXBwbHkoc2RrOiBJU0RLKTogUHJvbWlzZTxhbnk+IHtcbiAgICByZXR1cm4gc2RrLmxhbWJkYSgpLnVwZGF0ZUZ1bmN0aW9uQ29kZSh7XG4gICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICBTM0J1Y2tldDogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmNvZGUuczNCdWNrZXQsXG4gICAgICBTM0tleTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmNvZGUuczNLZXksXG4gICAgfSkucHJvbWlzZSgpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVzdGFibGlzaEZ1bmN0aW9uUGh5c2ljYWxOYW1lKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8c3RyaW5nIHwgdW5kZWZpbmVkPiB7XG4gIGNvbnN0IGZ1bmN0aW9uTmFtZUluQ2ZuVGVtcGxhdGUgPSBjaGFuZ2UubmV3VmFsdWU/LlByb3BlcnRpZXM/LkZ1bmN0aW9uTmFtZTtcbiAgaWYgKGZ1bmN0aW9uTmFtZUluQ2ZuVGVtcGxhdGUgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oZnVuY3Rpb25OYW1lSW5DZm5UZW1wbGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgZXZhbHVhdGUgdGhlIGZ1bmN0aW9uJ3MgbmFtZSBDbG91ZEZvcm1hdGlvbiBleHByZXNzaW9uLFxuICAgICAgLy8ganVzdCBsb29rIGl0IHVwIGluIHRoZSBjdXJyZW50bHkgZGVwbG95ZWQgU3RhY2tcbiAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKSkge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUGh5c2ljYWxOYW1lRm9yKGxvZ2ljYWxJZCk7XG59XG4iXX0=